legend.bg.alpha = 0.9,
legend.text.size = 0.6,
legend.title.size = 0.6,
inner.margins = c(0.1, 0.15, 0.1, 0.15)
)
coefPCTVACANT
#tmap_save(coefPCTVACANT, filename = "HW2_Plots/coefPCTVACANT_Map.png", width = 8, height = 8, dpi = 300)
arranged_coef <- tmap_arrange(coefLNNBELPOV, coefPCTBACHMOR, coefPCTSINGLES, coefPCTVACANT, ncol = 4)
arranged_coef
#tmap_save(arranged_coef, filename = "HW2_Plots/arranged_coef_Map.png", width = 8, height = 8, dpi = 300)
gwr_results
gwr_adaptive_residuals <- gwr_model$SDF$gwr.e
gwr_moran_mc <- moran.mc(gwr_adaptive_residuals, queenlist, nsim = 999)
gwr_moran_mc
# GWR adaptive moran's i plot
gwr_adaptive_plot <- moran.plot(gwr_adaptive_residuals, queenlist, main = "GWR Residual Moran Plot")
# GWR adaptive moran's i plot
gwr_adaptive_plot <- moran.plot(gwr_adaptive_residuals, queenlist)
# results using fixed bandwidth
gwr_model_fixed<-gwr(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT,
data=regress_spatial,
bandwidth = bandwidth_fixed, #fixed bandwidth
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
gwr_model_fixed
# GWR adaptive moran's i
gwr_fixed_residuals <- gwr_model_fixed$SDF$gwr.e
gwr_moran_mc <- moran.mc(gwr_fixed_residuals, queenlist, nsim = 999)
gwr_moran_mc
# GWR adaptive moran's i plot
gwr_adaptive_plot <- moran.plot(gwr_fixed_residuals, queenlist)
map <- tm_shape(regress_data)+
tm_fill(col='localR2',
breaks=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7),
n=5,
palette = 'Blues',
title = expression(Local~R^2)) +  # Add custom legend title
tm_borders(col = "white", lwd = 0.5) +
tm_layout(frame=FALSE)
map
# Compute Moran's I of residuals for each model to measures remaining spatial autocorrelation.
# The closer the Moran's I statistic is to 0, the better.
moran_ols <- moran.mc(standardised_res, queenlist, 999, alternative = "two.sided")
moran_lag <- moran.mc(lag_reg$residuals, queenlist, 999, alternative = "two.sided")
moran_error <- moran.mc(error_reg$residuals, queenlist, 999, alternative = "two.sided")
moran_gwr <- moran.mc(gwr_model$SDF$gwr.e, queenlist, 999, alternative = "two.sided")
moran_ols
moran_lag
moran_error
moran_gwr
# Compare AIC values.
# The lower the AIC, the better the model fit (after penalization).
aic_ols <- AIC(ols_reg)
aic_lag <- AIC(lag_reg)
aic_error <- AIC(error_reg)
aic_gwr <- gwr_model$results$AICc   # GWR reports a corrected AIC (AICc)
aic_ols
aic_lag
aic_error
aic_gwr
ols_resid <- residuals(ols_reg)
moran.plot(ols_resid, queenlist)
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
# Scatterplot of OLS residuals vs. spatially lagged residuals
plot(
regress_data$OLS_RESIDU, regress_data$WT_RESIDU,
xlab = "OLS Residuals (eᵢ)",
ylab = "Spatially Lagged Residuals (W eᵢ)",
main = "Moran’s I Scatterplot: OLS vs Weighted Residuals",
pch = 19, col = rgb(0, 0, 0, 0.5)
)
# Add regression line
fit <- lm(WT_RESIDU ~ OLS_RESIDU, data = regress_data)
abline(fit, col = "red", lwd = 2)
# Compute statistics
r <- cor(regress_data$OLS_RESIDU, regress_data$WT_RESIDU)
R2 <- summary(fit)$r.squared
slope <- coef(fit)[2]
pval <- summary(fit)$coefficients[2, 4]
# Display Moran-style summary on plot
legend("topleft",
legend = c(
paste0("Slope (≈ Moran’s I): ", round(slope, 3)),
paste0("Correlation (r): ", round(r, 3)),
paste0("R²: ", round(R2, 3)),
paste0("p-value: ", signif(pval, 3))
),
bty = "n"
)
abline(h = 0, v = 0, col = "gray70")  # reference lines
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran.plot(regress_data$OLS_RESIDU, queenlist)
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ mp$residuals))
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$residuals))
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$residuals))
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$x))
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist.)
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
# (a) Plot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (b) Text panel (not squished)
plot.new()
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
x11()   # on Windows/Linux
# quartz()   # on macOS
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
plot.new()
library(spdep)
# Compute Moran plot data and stats once
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# Open PNG graphics device (8×8 inches at 120 dpi → 960×960 pixels)
png("moran_plot_with_stats.png", width = 8, height = 8, units = "in", res = 120)
# Define layout: plot (top 80%), text (bottom 20%)
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
par(mar = c(4, 4, 3, 1))  # margins inside each panel
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (2) Text summary panel
plot.new()
text(0, 0.8, adj = 0,
labels = paste0(
"Slope (Moran’s I): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N: ", length(regress_data$OLS_RESIDU)
),
cex = 1.2, family = "mono")
# Close and save the PNG file
dev.off()
library(spdep)
# Compute Moran plot data and stats once
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# Open PNG graphics device (8×8 inches at 120 dpi → 960×960 pixels)
png("moran_plot_with_stats.png", width = 6, height = 8, units = "in", res = 120)
# Define layout: plot (top 80%), text (bottom 20%)
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
par(mar = c(4, 4, 3, 1))  # margins inside each panel
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (2) Text summary panel
plot.new()
text(0, 0.8, adj = 0,
labels = paste0(
"Slope (Moran’s I): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N: ", length(regress_data$OLS_RESIDU)
),
cex = 1.2, family = "mono")
# Close and save the PNG file
dev.off()
library(spdep)
# Compute Moran plot data and stats once
library(spdep)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm  <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
png("moran_plot_with_stats_fixed.png", width = 6, height = 8, units = "in", res = 150)
# Give 85% of height to plot, 15% to text
layout(matrix(c(1, 2), nrow = 2), heights = c(5, 1))
par(mar = c(4, 4, 3, 1))
# Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
# Text panel (smaller text and positioned higher)
plot.new()
png("OLS_RESIDU_Plot.png", width = 8, height = 6, units = "in", res = 150)
moran.plot(regress_data$OLS_RESIDU, queenlist)
dev.off()
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$x))
#| eval: false
#| echo: true
library(sf)
library(dplyr)
library(tibble)
library(spdep)
library(spgwr)
library(tmap)
library(spatialreg)
library(whitestrap)
library(lmtest)
library(tseries)
options(scipen=999)
#Read the Regression Data shp
regress_data <- st_read("data/RegressionData.shp")
#Create variable PLUS1, defined as NBELPOV100+1
#We already have LNNBELPOV and LNMEDHVAL in the shapefile (1.a.iv, 1.a.v in hw instructions)
regress_data <- regress_data %>%
mutate(
PLUS1 = NBelPov100 + 1,
)
#Before proceeding, let’s examine the distributions of our variables and see whether we need to create log transformations of any of them
par(oma=c(0,0,2,0))
par(mfrow=c(1,3))
hist(regress_data$MEDHHINC, breaks = 50)
hist(regress_data$MEDHVAL, breaks = 50)
hist(regress_data$PCTVACANT, breaks = 50)
#PCTVANCANT has a spike at 0, so not transformation for them. MEDHHINC and MEDHVAL will be transformed/they already exist in the regress_data gdf.
#Graph of LNMED(HH)INC, LNMEDHVAL, and PCTVACANT
par(oma=c(0,0,2,0))
par(mfrow=c(1,3))
hist(regress_data$LNMEDINC, breaks = 50)
hist(regress_data$LNMEDHVAL, breaks = 50)
hist(regress_data$PCTVACANT, breaks = 50)
#I am making an assumption that LNMEDINC in the log of MEDHHINC. To reiterate, the LNMEDINC and LNMEDVHAL are present when you load the regress_data shp.
#defining neighbors for each of the block groups in philly using queen neighbors
queen_neighbors <- poly2nb(regress_data, row.names = regress_data$POLY_ID)
summary(queen_neighbors)
#It is useful to examine where block groups with non-average neighbor patterns are situated before we run spatial analyses. This is because these outlier block groups will affect our spatial analyses. We will look at the block groups where there is only 1 neighbor, and block groups where there are 27 neighbors. The block groups themselves will be colored in red, and their neighbors in green
#see which region has only one neighbor
smallestnbcard<-card(queen_neighbors) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen_neighbors[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen_neighbors[[smallestnb[2]]]]<-'green'
fg[queen_neighbors[[smallestnb[3]]]]<-'green'
fg[queen_neighbors[[smallestnb[4]]]]<-'green'
plot(regress_data$geometry, col=fg)
title(main='Regions with only 1 neighbor')
#block group with most neighbors
largestnbcard<-card(queen_neighbors)
largestnb<-which(largestnbcard == max(largestnbcard))
fg1<-rep('grey90', length(largestnbcard))
fg1[largestnb]<-'red'
fg1[queen_neighbors[[largestnb]]]<-'green'
plot(regress_data$geometry, col=fg1)
title(main='Region with 27 neighbors')
#Choosing W as the style parameter, which will perform row standardization.
queenlist <- nb2listw(queen_neighbors, style = "W")
moran(regress_data$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0 =Szero(queenlist))$"I"
# Check if this measure is statistically significant
moranI_mc <- moran.mc(regress_data$LNMEDHVAL, queenlist, nsim=999, alternative="two.sided")  #We use 999 permutations
moranI_mc
# Histogram of the Moran’s I values from random permutations
moranI_mc_res<-moranI_mc$res
hist(moranI_mc_res, freq=10000000, nclass=100)   #Draws distribution of Moran's I's calculated from randomly permuted values
# Here, we draw a red vertical line at the observed value of our Moran's I
abline(v=moran(regress_data$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`, col='red')
#Create Moran plot (lagged value against observed value)
moran.plot(regress_data$LNMEDHVAL, queenlist)
#Run local moran's I (LISA)
lmoran<-localmoran(regress_data$LNMEDHVAL, queenlist)
head(lmoran)
# Combine the original regression dataset with the Local Moran's I results so that each observation includes its corresponding local spatial statistic
lmoran_df <-cbind(regress_data, as.data.frame(lmoran))
library(tmap)
tmap_mode("plot")
#Obtaining the Local Moran's P-Values (two-sided)
regress_data$local_I <- lmoran[, "Pr(z != E(Ii))"]
library(sf)
regress_data <- st_make_valid(regress_data) #Sometimes necessary if projection is off
#Creating the LISA Clusters
moran_plot <- moran.plot(as.vector(scale(regress_data$LNMEDHVAL)), queenlist)
#Read the Regression Data shp
regress_data <- st_read("data/RegressionData.shp")
#Create variable PLUS1, defined as NBELPOV100+1
#We already have LNNBELPOV and LNMEDHVAL in the shapefile (1.a.iv, 1.a.v in hw instructions)
regress_data <- regress_data %>%
mutate(
PLUS1 = NBelPov100 + 1,
)
#Before proceeding, let’s examine the distributions of our variables and see whether we need to create log transformations of any of them
par(oma=c(0,0,2,0))
par(mfrow=c(1,3))
hist(regress_data$MEDHHINC, breaks = 50)
hist(regress_data$MEDHVAL, breaks = 50)
hist(regress_data$PCTVACANT, breaks = 50)
#PCTVANCANT has a spike at 0, so not transformation for them. MEDHHINC and MEDHVAL will be transformed/they already exist in the regress_data gdf.
#Graph of LNMED(HH)INC, LNMEDHVAL, and PCTVACANT
par(oma=c(0,0,2,0))
par(mfrow=c(1,3))
hist(regress_data$LNMEDINC, breaks = 50)
hist(regress_data$LNMEDHVAL, breaks = 50)
hist(regress_data$PCTVACANT, breaks = 50)
#I am making an assumption that LNMEDINC in the log of MEDHHINC. To reiterate, the LNMEDINC and LNMEDVHAL are present when you load the regress_data shp.
#defining neighbors for each of the block groups in philly using queen neighbors
queen_neighbors <- poly2nb(regress_data, row.names = regress_data$POLY_ID)
summary(queen_neighbors)
#It is useful to examine where block groups with non-average neighbor patterns are situated before we run spatial analyses. This is because these outlier block groups will affect our spatial analyses. We will look at the block groups where there is only 1 neighbor, and block groups where there are 27 neighbors. The block groups themselves will be colored in red, and their neighbors in green
#see which region has only one neighbor
smallestnbcard<-card(queen_neighbors) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen_neighbors[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen_neighbors[[smallestnb[2]]]]<-'green'
fg[queen_neighbors[[smallestnb[3]]]]<-'green'
fg[queen_neighbors[[smallestnb[4]]]]<-'green'
plot(regress_data$geometry, col=fg)
title(main='Regions with only 1 neighbor')
#block group with most neighbors
largestnbcard<-card(queen_neighbors)
largestnb<-which(largestnbcard == max(largestnbcard))
fg1<-rep('grey90', length(largestnbcard))
fg1[largestnb]<-'red'
fg1[queen_neighbors[[largestnb]]]<-'green'
plot(regress_data$geometry, col=fg1)
title(main='Region with 27 neighbors')
#Choosing W as the style parameter, which will perform row standardization.
queenlist <- nb2listw(queen_neighbors, style = "W")
moran(regress_data$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0 =Szero(queenlist))$"I"
# Check if this measure is statistically significant
moranI_mc <- moran.mc(regress_data$LNMEDHVAL, queenlist, nsim=999, alternative="two.sided")  #We use 999 permutations
moranI_mc
# Histogram of the Moran’s I values from random permutations
moranI_mc_res<-moranI_mc$res
hist(moranI_mc_res, freq=10000000, nclass=100)   #Draws distribution of Moran's I's calculated from randomly permuted values
# Here, we draw a red vertical line at the observed value of our Moran's I
abline(v=moran(regress_data$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`, col='red')
#Create Moran plot (lagged value against observed value)
moran.plot(regress_data$LNMEDHVAL, queenlist)
#Run local moran's I (LISA)
lmoran<-localmoran(regress_data$LNMEDHVAL, queenlist)
head(lmoran)
# Combine the original regression dataset with the Local Moran's I results so that each observation includes its corresponding local spatial statistic
lmoran_df <-cbind(regress_data, as.data.frame(lmoran))
library(tmap)
tmap_mode("plot")
#Obtaining the Local Moran's P-Values (two-sided)
regress_data$local_I <- lmoran[, "Pr(z != E(Ii))"]
library(sf)
regress_data <- st_make_valid(regress_data) #Sometimes necessary if projection is off
#Creating the LISA Clusters
moran_plot <- moran.plot(as.vector(scale(regress_data$LNMEDHVAL)), queenlist)
regress_data$quadrant <- NA
# high-high
regress_data[(moran_plot$x >= 0 & moran_plot$wx >= 0) & (regress_data$local_I <= 0.05), "quadrant"]<- 1
# low-low
regress_data[(moran_plot$x <= 0 & moran_plot$wx <= 0) & (regress_data$local_I <= 0.05), "quadrant"]<- 2
# high-low
regress_data[(moran_plot$x >= 0 & moran_plot$wx <= 0) & (regress_data$local_I <= 0.05), "quadrant"]<- 3
# low-high
regress_data[(moran_plot$x <= 0 & moran_plot$wx >= 0) & (regress_data$local_I <= 0.05), "quadrant"]<- 4
# non-significant
regress_data[(regress_data$local_I > 0.05), "quadrant"] <- 5
# LISA P-Value Map
p_vals <- tm_shape(regress_data) +
tm_polygons(col = "local_I", title = "",
breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
palette = c("darkblue", "blue", "lightblue", "white")) +
tm_borders(col = "gray", lwd = 0.5) +
tm_layout(
legend.outside = TRUE,
legend.text.size = 1,
legend.title.size = 1,
fontfamily = "Arial",
title = "LISA P-Value Map",
title.size = 1.2,
frame = FALSE
)
p_vals
#tmap_save(p_vals, filename = "HW2_Plots/p_vals_Map.png", width = 8, height = 8, dpi = 300)
# LISA Cluster Map
lisa_clusters <- tm_shape(regress_data) +
tm_fill(col = "quadrant", title = "",
breaks = c(1, 2, 3, 4, 5, 6),
palette = c("red", "blue", "lightpink", "skyblue2", "white"),
labels = c("High-High", "Low-Low", "High-Low", "Low-High", "Non-significant")) +
tm_borders(alpha = 0.5) +
tm_borders(col = "gray", lwd = 0.5) +
tm_layout(
frame = FALSE,
legend.outside = TRUE,
legend.text.size = 1,
legend.title.size = 1,
fontfamily = "Arial",
title = "LISA Cluster Map",
title.size = 1.2
)
lisa_clusters
#tmap_save(lisa_clusters, filename = "HW2_Plots/lisa_clusters_Map.png", width = 8, height = 8, dpi = 300)
# Fit an Ordinary Least Squares (OLS) regression model
# Dependent variable: LNMEDINC (log of median income)
# Independent variables: LNMEDHVAL (log of median home value) and PCTVACANT (percent of vacant housing)
ols_reg<-lm(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT, data=regress_data)
summary(ols_reg)
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
#png("OLS_RESIDU_Plot.png", width = 8, height = 6, units = "in", res = 150)
#moran.plot(regress_data$OLS_RESIDU, queenlist)
#dev.off()
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$x))
#Prints the log likelihood
logLik(ols_reg)
#Prints the results of the Breusch-Pagan Test to assess whether heteroscedasticity is present (package: lmtest)
bptest(ols_reg, studentize=FALSE)
#Prints the results of the Koenker-Bassett Test (also known as the Studentized Breusch-Pagan Test) to assess whether heteroscedasticity is present (package: lmtest)
bptest(ols_reg)
#Prints the results of the White Test to assess whether heteroscedasticity is present (package: whitestrap)
white_test(ols_reg)
# Prints the results of the Jarque-Bera Test to assess whether residuals are normal (package: tseries)
jarque.bera.test(ols_reg$residuals)
