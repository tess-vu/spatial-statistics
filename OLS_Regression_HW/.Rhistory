theme_void()
choropleth_PCTBACHMOR <- ggplot() +
geom_sf(data = shapefile, aes(fill = PCTBACHMOR), color = "cornsilk2", linewidth = 0.25) +
scale_fill_viridis_c() +
labs(fill = "% Bachelor's Degrees") +
theme_void()
choropleth_LNNBELPOV100 <- ggplot() +
geom_sf(data = shapefile, aes(fill = LNNBELPOV), color = "black", linewidth = 0.25) +
scale_fill_viridis_c() +
labs(fill = "Households in Poverty") +
theme_void()
plots_combined <- plot_grid(choropleth_PCTVACANT, choropleth_PCTSINGLES, choropleth_PCTBACHMOR, choropleth_LNNBELPOV100, ncol = 2, nrow = 2)
plots_combined + plot_annotation(
title = "Philadelphia Tracts",
subtitle = "Median House Value Predictors"
)
#ggsave("choropleth_combined_map.png", plot = plots_combined, width = 14, height = 8.5, units = "in", dpi = 300)
plots_combined
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
show.diag = TRUE
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
show.diag = TRUE
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726"),
show.diag = TRUE
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "upper",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726"),
show.diag = TRUE
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "upper",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "upper",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726"),
show.diag = TRUE
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",              # Show full matrix including diagonal
lab = TRUE,                 # Add correlation coefficients
lab_size = 3,               # Label size
digits = 2,                 # Decimal places
hc.order = TRUE,            # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full", # Show full matrix including diagonal
lab = TRUE, # Add correlation coefficients
lab_size = 4, # Label size
digits = 2, # Decimal places
hc.order = TRUE, # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",
lab = TRUE, # Add correlation coefficients
lab_size = 2, # Label size
digits = 2, # Decimal places
hc.order = TRUE, # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
colnames(correlation_matrix) <- new_names
rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",
lab = TRUE, # Add correlation coefficients
lab_size = 3, # Label size
digits = 2, # Decimal places
hc.order = TRUE, # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
correlation_matrix <- cor(regress_data[, c("LNPCTBACHMORE", "LNNBELPOV100", "LNPCTVACANT", "LNPCTSINGLES")],
use = "complete.obs",
method = "pearson")
print(correlation_matrix)
# Create a vector of new names in the desired order
#new_names <- c("ln(% Bachelor's +)", "ln(# Below Poverty)", "ln(% Vacancies)", "ln(% Detached)") # Adjust to your number of variables
# Assign the new names to the dimensions of the matrix
#colnames(correlation_matrix) <- new_names
#rownames(correlation_matrix) <- new_names
ggcorrplot(
correlation_matrix,
type = "full",
lab = TRUE, # Add correlation coefficients
lab_size = 3, # Label size
digits = 2, # Decimal places
hc.order = TRUE, # Hierarchical clustering for variable ordering
outline.col = "white",
ggtheme = ggplot2::theme_gray(),
colors = c("#6D9EC1", "white", "#E46726")
)
# Regression analysis.
regress_analysis <- lm(LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV100, regress_data)
regress_analysis
# Summary of fit for regression analysis.
regress_summary <- summary(regress_analysis)
regress_summary
# ANOVA.
regress_anova <- anova(regress_analysis)
regress_anova
# Fitted.
regress_predicted <- fitted(regress_analysis)
glimpse(regress_predicted)
# Residuals.
regress_residuals <- residuals(regress_analysis)
glimpse(regress_residuals)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
glimpse(regress_standard_residuals)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
predicted_residual_data
# Regression analysis.
regress_analysis <- lm(LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV100, regress_data)
summary(regress_analysis)
# Scatter plot of ln(percent bachelor's degrees) vs. ln(median house value).
plot_LNPCTBACHMORE <- ggplot(regress_data, aes(x = LNPCTBACHMORE, y = LNMEDHVAL)) +
geom_point(size = 2, alpha = 0.3, color = "midnightblue") +
labs(title = "LOG: Percent Bachelor's Degree vs. Median House Value",
x = "Percent Bachelor's Degree",
y = "Median House Value") +
theme_gray()
# Scatter plot of ln(number households in poverty) vs. ln(median house value).
plot_LNNBELPOV100 <- ggplot(regress_data, aes(x = LNNBELPOV100, y = LNMEDHVAL)) +
geom_point(size = 2, alpha = 0.3, color = "midnightblue") +
labs(title = "LOG: Number Households in Poverty vs. Median House Value",
x = "Number Households in Poverty",
y = "Median House Value") +
theme_gray()
# Scatter plot of ln(percent vacant units) vs. ln(median house value).
plot_LNPCTVACANT <- ggplot(regress_data, aes(x = LNPCTVACANT, y = LNMEDHVAL)) +
geom_point(size = 2, alpha = 0.3, color = "midnightblue") +
labs(title = "LOG: Percent Vacant Units vs. Median House Value",
x = "Percent Vacant Units",
y = "Median House Value") +
theme_gray()
# Scatter plot of ln(detached single-family homes) vs. ln(median house value).
plot_LNPCTSINGLES <- ggplot(regress_data, aes(x = LNPCTSINGLES, y = LNMEDHVAL)) +
geom_point(size = 2, alpha = 0.3, color = "midnightblue") +
labs(title = "LOG: Percent Detached Single-Family Homes vs. Median House Value",
x = "Percent Detached Single-Family Homes",
y = "Median House Value") +
theme_gray()
# Create combined scatter plots with 2 rows and 2 columns.
plots_combined <- plot_grid(plot_LNPCTBACHMORE, plot_LNNBELPOV100, plot_LNPCTVACANT, plot_LNPCTSINGLES, ncol = 2, nrow = 2)
# Display plots with annotation.
plots_combined + plot_annotation(
title = "NATURAL LOG: Median House Value Predictors",
subtitle = "Using % Bachelor's Degrees, # Households Below Poverty,\n% Vacant Units, % Detached Single-Family Homes"
)
# Fitted.
regress_predicted <- fitted(regress_analysis)
# Residuals.
regress_residuals <- residuals(regress_analysis)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
# Histogram of percent detached single house units.
pctbachmor_histogram <- ggplot(predicted_residual_data$R_RESIDUALS, aes(x = PCTSINGLES)) +
geom_histogram(fill = "blue2", color = "white") +
scale_x_continuous(labels = scales::label_percent(scale = 1, big.mark = ",")) +
labs(
title = "Histogram of Percent Detached Homes",
x = "Percent Detached Homes (Percent, %)",
y = "Count"
) +
theme_minimal(base_family = "Times New Roman") +
theme(
plot.title = element_text(face = "bold", size = 12),
axis.title.x = element_text(face = "italic", size = 10),
axis.title.y = element_text(face = "italic", size = 10)
)
# Fitted.
regress_predicted <- fitted(regress_analysis)
# Residuals.
regress_residuals <- residuals(regress_analysis)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
# Histogram of percent detached single house units.
pctbachmor_histogram <- ggplot(predicted_residual_data, aes(x = `R_RESIDUALS`)) +
geom_histogram(fill = "blue2", color = "white") +
scale_x_continuous(labels = scales::label_percent(scale = 1, big.mark = ",")) +
labs(
title = "Histogram of Percent Detached Homes",
x = "Percent Detached Homes (Percent, %)",
y = "Count"
) +
theme_minimal(base_family = "Times New Roman") +
theme(
plot.title = element_text(face = "bold", size = 12),
axis.title.x = element_text(face = "italic", size = 10),
axis.title.y = element_text(face = "italic", size = 10)
)
pctbachmor_histogram
# Fitted.
regress_predicted <- fitted(regress_analysis)
# Residuals.
regress_residuals <- residuals(regress_analysis)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
# Histogram of standardized residuals.
pctbachmor_histogram <- ggplot(predicted_residual_data, aes(x = `R_STANDARD`)) +
geom_histogram(fill = "blue2", color = "white") +
scale_x_continuous(labels = scales::label_percent(scale = 1, big.mark = ",")) +
labs(
title = "Histogram of Standardized Residuals",
x = "Standardized Residuals",
y = "Count"
) +
theme_minimal(base_family = "Times New Roman") +
theme(
plot.title = element_text(face = "bold", size = 12),
axis.title.x = element_text(face = "italic", size = 10),
axis.title.y = element_text(face = "italic", size = 10)
)
pctbachmor_histogram
# Fitted.
regress_predicted <- fitted(regress_analysis)
# Residuals.
regress_residuals <- residuals(regress_analysis)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
# Histogram of standardized residuals.
pctbachmor_histogram <- ggplot(predicted_residual_data, aes(x = `R_STANDARD`)) +
geom_histogram(fill = "blue2", color = "white") +
labs(
title = "Histogram of Standardized Residuals",
x = "Standardized Residuals",
y = "Count"
) +
theme_minimal(base_family = "Times New Roman") +
theme(
plot.title = element_text(face = "bold", size = 12),
axis.title.x = element_text(face = "italic", size = 10),
axis.title.y = element_text(face = "italic", size = 10)
)
pctbachmor_histogram
# Fitted.
regress_predicted <- fitted(regress_analysis)
# Residuals.
regress_residuals <- residuals(regress_analysis)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
# Histogram of standardized residuals.
pctbachmor_histogram <- ggplot(predicted_residual_data, aes(x = `R_STANDARD`)) +
geom_histogram(fill = "lightblue", color = "white") +
labs(
title = "Histogram of Standardized Residuals",
x = "Standardized Residuals",
y = "Count"
) +
theme_minimal(base_family = "Times New Roman") +
theme(
plot.title = element_text(face = "bold", size = 12),
axis.title.x = element_text(face = "italic", size = 10),
axis.title.y = element_text(face = "italic", size = 10)
)
pctbachmor_histogram
# Scatter plot.
predicted_residual_plot <- ggplot(predicted_residual_data, aes(x = R_PREDICTED, y = R_STANDARD)) +
geom_point(size = 2, alpha = 0.3, color = "midnightblue") +
labs(title = "Predicted Values vs. Standardized Residuals",
x = "Predicted Values",
y = "Standardized Residuals") +
theme_gray()
predicted_residual_plot
library(MASS)
step_model <- step(regress_analysis, direction = "both")
step_model$anova
hist_residuals <- ggplot(predicted_residual_data, aes(x = R_STANDARD)) +
geom_histogram(bins = 30, fill = "midnightblue", color = "white", alpha = 0.8) +
labs(title = "Histogram of Standardized Residuals",
x = "Standardized Residuals",
y = "Count") +
theme_minimal()
hist_residuals
#ggsave("histogram_standardized_residuals.png", plot = hist_residuals, width = 8, height = 6, dpi = 300)
#| message: false
#| warning: false
# Fitted.
regress_predicted <- fitted(regress_analysis)
# Residuals.
regress_residuals <- residuals(regress_analysis)
# Standardized residuals.
regress_standard_residuals <- rstandard(regress_analysis)
# Creating new empty dataframe with 3 columns and 1,720 rows for above calculations to store and plot.
predicted_residual_data <- data.frame(matrix(NA, nrow = 1720, ncol = 3))
colnames(predicted_residual_data) <- c("R_PREDICTED", "R_RESIDUALS", "R_STANDARD")
# Store calculated values into new dataframe.
predicted_residual_data <- predicted_residual_data %>%
mutate(
R_PREDICTED = regress_predicted,
R_RESIDUALS = regress_residuals,
R_STANDARD = regress_standard_residuals
)
# Histogram of standardized residuals.
hist_residuals <- ggplot(predicted_residual_data, aes(x = R_STANDARD)) +
geom_histogram(bins = 30, fill = "midnightblue", color = "white", alpha = 0.8) +
labs(title = "Histogram of Standardized Residuals",
x = "Standardized Residuals",
y = "Count") +
theme_minimal()
hist_residuals
